#!/usr/bin/env perl
#
# Example implementation for the Git filter protocol version 2
# See Documentation/gitattributes.txt, section "Filter Protocol"
#
# Please note, this pass-thru filter is a minimal skeleton. No proper
# error handling was implemented.
#
# This file is a modification of the long-running-filter example from
# git v2.17.1. It's modified to not barf on newer filter capabilities
# and to handle smudge/clean for \$FreeBSD\$ SVN annotations.
# The original didn't have an explicit licence, so I'm assuming it's
# GPLv2 like the rest of git.
#
# to use execute the following:
# git config --add filter.freebsdid.process <path to git-keyword-filter>
# git config --add filter.freebsdid.required true
# then add the line:
# * filter=freebsdid
# to your attributes file ($(git rev-parse --git-path info/attributes) by default)
#
# $FreeBSD$

use strict;
use warnings;

use Digest::SHA qw(sha1 sha1_hex sha1_base64);

my $MAX_PACKET_CONTENT_SIZE = 65516;

sub packet_bin_read {
	my $buffer;
	my $bytes_read = read STDIN, $buffer, 4;
	if ( $bytes_read == 0 ) {

		# EOF - Git stopped talking to us!
		exit();
	}
	elsif ( $bytes_read != 4 ) {
		die "invalid packet: '$buffer'";
	}
	my $pkt_size = hex($buffer);
	if ( $pkt_size == 0 ) {
		return ( 1, "" );
	}
	elsif ( $pkt_size > 4 ) {
		my $content_size = $pkt_size - 4;
		$bytes_read = read STDIN, $buffer, $content_size;
		if ( $bytes_read != $content_size ) {
			die "invalid packet ($content_size bytes expected; $bytes_read bytes read)";
		}
		return ( 0, $buffer );
	}
	else {
		die "invalid packet size: $pkt_size";
	}
}

sub packet_txt_read {
	my ( $res, $buf ) = packet_bin_read();
	if ( $res == 1 ) {
		return ( 1, $buf );
	}
	unless ( $buf =~ s/\n$// ) {
		die "A non-binary line MUST be terminated by an LF.";
	}
	return ( $res, $buf );
}

sub packet_bin_write {
	my $buf = shift;
	print STDOUT sprintf( "%04x", length($buf) + 4 );
	print STDOUT $buf;
	STDOUT->flush();
}

sub packet_txt_write {
	packet_bin_write( $_[0] . "\n" );
}

sub packet_flush {
	print STDOUT sprintf( "%04x", 0 );
	STDOUT->flush();
}

sub smudge {
	# TODO: Make use of these...
	my $blob = $_[0];
	my $file = $_[1];
	my $blobid = $_[2];
	my $ref = $_[3];
	my $tree = $_[4];

	if ( $blobid eq "" ) {
		#$blobid = sha1_hex("blob ", length($blob), "\0", $blob);
		print STDERR sprintf( "file: %s no blob (%s), ref (%s), tree (%s)\n", $file, $blobid, $ref, $tree);
		return $blob
	}

	my $repl = sprintf("\$FreeBSD: \@:%s %.12s git \$", $file, $blobid);

	# Use FreeBSD: @:<path> for two reasons:
	# 1) It's the git syntax to find the file in the current branch
	# 2) It avoids cleaning tags that come from CVS or Subversion when
	# svn:keywords is unset.
	$blob =~ s|\$FreeBSD\$|$repl|g;
	return $blob;
}

sub clean {
	my $blob = $_[0];
	$blob =~ s|\$FreeBSD: \@:[\S]+\s[\S]+\s(git )?\$|\$FreeBSD\$|g;
	return $blob;
}

( packet_txt_read() eq ( 0, "git-filter-client" ) ) || die "bad initialize";
( packet_txt_read() eq ( 0, "version=2" ) )         || die "bad version";
( packet_bin_read() eq ( 1, "" ) )                  || die "bad version end";

packet_txt_write("git-filter-server");
packet_txt_write("version=2");
packet_flush();

( packet_txt_read() eq ( 0, "capability=clean" ) )  || die "bad capability";
( packet_txt_read() eq ( 0, "capability=smudge" ) ) || die "bad capability";
( packet_txt_read() eq ( 0, "capability=delay" ) )  || die "bad capability";
( packet_bin_read() eq ( 1, "" ) )                  || die "bad capability end";

packet_txt_write("capability=clean");
packet_txt_write("capability=smudge");
packet_flush();

while (1) {
	my $command = "";
	my $pathname = "";
	my $refname = "@";
	my $treeish = "@";
	my $blobbb = "";
	my $res = 0;

	do {
		my $buf;
		($res, $buf) = packet_txt_read();
		#$buf =~ s/\n$//;
		#print STDERR sprintf( "res %d, pkt: %s\n", $res, $buf);
		if ( $buf =~ /^command=(.+)$/ ) {
			$command = $1;
		}
		if ( $buf =~ /^pathname=(.+)$/ ) {
			$pathname = $1;
		}
		if ( $buf =~ /^treeish=(.+)$/ ) {
			$treeish = $1;
		}
		if ( $buf =~ /^ref=(.+)$/ ) {
			$refname = $1;
		}
		if ( $buf =~ /^blob=(.+)$/ ) {
			$blobbb = $1;
		}
	} while ( $res == 0 );

	if ( $pathname eq "" ) {
		die "bad pathname '$pathname'";
	}

	my $input = "";
	{
		binmode(STDIN);
		my $buffer;
		my $done = 0;
		while ( !$done ) {
			( $done, $buffer ) = packet_bin_read();
			$input .= $buffer;
		}
	}

	my $output;
	if ( $command eq "clean" ) {
		### Perform clean here ###
		$output = clean($input);
	}
	elsif ( $command eq "smudge" ) {
		### Perform smudge here ###
		$output = smudge($input,$pathname,$blobbb,$refname,$treeish);
	}
	else {
		die "bad command '$command'";
	}

	packet_txt_write("status=success");
	packet_flush();
	while ( length($output) > 0 ) {
		my $packet = substr( $output, 0, $MAX_PACKET_CONTENT_SIZE );
		packet_bin_write($packet);
		if ( length($output) > $MAX_PACKET_CONTENT_SIZE ) {
			$output = substr( $output, $MAX_PACKET_CONTENT_SIZE );
		}
		else {
			$output = "";
		}
	}
	packet_flush();    # flush content!
	packet_flush();    # empty list, keep "status=success" unchanged!

}
